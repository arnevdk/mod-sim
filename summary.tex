\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[dutch]{babel}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{bbold}
\usepackage{todonotes}
\usepackage{systeme}

\title{
	G0Q57A: Modellering en simulatie\\
	Samenvatting
}
\author{Arne Van Den Kerchove - \texttt{arne@vandenkerchove.com}}

\newtheorem{mydef}{Definitie}

\newcommand{\norm}[1]{\left\lVert#1\right\rVert}

\setlength\parindent{0pt}

\begin{document}
	\maketitle
	
	\pagebreak
	
	\tableofcontents
	
	\pagebreak	
	
	\todo{Antwoorden op examnevragen opnemen}
	
	\section{Modellen en simulaties}
	
	\todo{Dit hoofdstuk als er tijd over is}
	
	
	
	\section{Numerieke lineaire algebra en toepassingen}
	
	\subsection{QR-factorisatie}
	
	
	\begin{mydef}
		De volle QR-factorisatie van de matrix $A$ wordt gegeven door
		$$	A=QR  $$
		met $q$ een $m \times m$ orthogonale matrix en $R$ een $m \times n $ bovendriehoeksmatrix.
	\end{mydef}

	\subsubsection{Gram-Schmidt orthogonalisatie}
	

	\begin{algorithm}[!ht]
		\caption{Gram-Schmidt-algoritme}
		\begin{algorithmic}[1]
			\Procedure{QRGramSchmidt}{}
				\For{$j=1$ to $n$}
					\State $v_j = a_j$
					\For{$i=1$ to $j-1$}
						\State $r_{ij} = q_i^T a_j$
						\State $v_j = v_j - r_{ij} q_i$
					\EndFor
					\State $r_{jj} = \norm{v_j}_2$
					\State $q_j = v_j/r_{jj}$
				\EndFor 
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}

	\textbf{Complexiteit:} $\mathcal{O}(2mn^2)$\\
	\textbf{Stabiliteit:} niet stabiel
	
	\subsubsection{QR-factorisatie met Givens-rotaties}
	
	\begin{mydef}
		Een Givens-rotatie is een $m \times m$ orthogonale matrix van de vorm
		$$
		G_{ij} = 
		\begin{bmatrix}
			c & -s \\
			s &  c  
		\end{bmatrix}
		$$
		met
		$$ c^2 + s^2 = 1 $$
	\end{mydef}

	Om een Givens-rotatie op te stellen die plaats $(j,k)$ $0$ maakt in matrix $A$, kies dan een element in dezelfde kolom (bv. het element boven $(j,k)$) op plaats $(i,k)$ en maak $G_{ij}$ met
	$$ c = \frac{a_{ik}}{\sqrt{a_{ik}^2 + a_{jk}^2}} \text{ en } s = \frac{a_{jk}}{\sqrt{a_{ik}^2 + a_{jk}^2}}$$
	
	\begin{algorithm}[!ht]
		\caption{Givens-rotatie-algoritme}
		\begin{algorithmic}[1]
			\Procedure{QRGivens}{}
				\State $Q=\mathbb{1}$
				\State $R=A$
				\For{$j=1$ to $n$}
					\For{$i=m$ to $j+1$}
						\State $c = \frac{r_{i-1,j}}{\sqrt{r_{i-1,j}^2 + r_{i,j}^2}}$
						\State $s = \frac{r_{i,j}}{\sqrt{r_{i-1,j}^2 + r_{i,j}^2}}$
						\State $r_{i,j} = 0$
						\State $r_{i-1,j} = \sqrt{r_{i-1,j}^2 + r_{i,j}^2}$
						\For{$k=j+1$ to $n$}
							\State 
							$$
								\begin{bmatrix}
									r_{i-1,k} \\
									r_{ik}
								\end{bmatrix}
								=
								\begin{bmatrix}
									c & s \\
									-s & s
								\end{bmatrix}
								\begin{bmatrix}
									r_{i-1,k} \\
									r_{i,k}
								\end{bmatrix}
							$$
						\EndFor
						\For{$k=1$ to $m$}
							\State
							$$
								\begin{bmatrix}
									q_{k,i-1} & q_{ki}
								\end{bmatrix}
								=
								\begin{bmatrix}
									q_{k,i-1} & q_{ki}
								\end{bmatrix}
								\begin{bmatrix}
									c & s \\
									-s & s
								\end{bmatrix}
							$$
						\EndFor
					\EndFor
				\EndFor
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}

	\textbf{Complexiteit:} $\mathcal{O}(3mn^2 - n^3)$ \\
	\textbf{Stabiliteit:} stabiel


	
	\subsubsection{QR-factorisatie met kolompivotering}
	Indien $A$ niet van volle rang is, is het voor de stabiliteit beter om kolompivotering toe te passen. In stap $j$ van het QR-algoritme met Givens-rotaties verwisselen we kolom $j$ met de kolom $p$ waarvan de 2-norm het grootst is.\\
		
	\textbf{Complexiteit:} $\mathcal{O}(3mn^2 - n^3)$ \\
	\textbf{Stabiliteit:} stabieler voor rang-deficiënte matrices
	
	\subsection{Singuliere-waardenontbinding}
	
	\begin{mydef}
		De singuliere-waardenontbinding van matrix $A$ wordt gegeven door
		$$
		A = \hat{U}\hat{\Sigma}V^T
		$$
		waarbij $\hat{U}$ orthonormale kolommen heeft, $\hat{\Sigma}$ een diagonaalmatrix met de singuliere waarden is en $V$ een orthogonale matrix is.
	\end{mydef}

	Eigenschappen van de SVD:
	\begin{itemize}
		\item De rang van $A$ is gelijk aan de rang van $\Sigma$ is gelijk aan het aantal niet-nul singuliere waarden.
		\item De eerste $r$ kolommen van $U$ vormen een basis voor de kolomruimte van $A$.
		\item De laatste $n-r$ kolommen van $V$ vormen een basis voor de nulruimte van $A$.
		\item $ A = U \Sigma V^T = \sum_{i=1}^{r} \sigma_i u_i v_i^T $
		\item $ norm{A}_2 = \sqrt(\sigma_1^2 + \sigma_2^2 + ... + \sigma_r^2) $
		\item De singuliere waarden zijn de vierkantswortels van de eigenwaarden van $A^TA$. De kolommen van $V$ zijn de bijhorende eigenvectoren.
		\item De singuliere waarden zijn de vierkantswortels van de $n$ grootste eigenwaarden van $AA^T$. De eerste $n$ kolommen van $U$ zijn de bijhorende eigenvectoren.
		\item Als $A$ symmetrisch is, zijn de singuliere waarden de absolute waarden van de eigenwaarden van $A$.
	\end{itemize}

	\subsubsection{Lage rangbenadering}
	
	\begin{mydef}
		De $\epsilon$-rang van een matrix $A$ wordt gedefinieerd als
		$$
			rang(A,\epsilon) = \min_{\norm{A-B}_2 \leq \epsilon} \text{rang}(B)
		$$
	\end{mydef}
	De matrix $B$ ligt $\epsilon$-dicht bij $A$ als hij een rang heeft die de kleinste is onder alle matrices die $\epsilon$-dicht bij $A$ liggen.
	
	\begin{mydef}
		Een rang k-benadering $A_k$ met $(k \leq r)$ van $A$ wordt berekend door de singuliere waardenontbinding te vermenigvuldigen, maar $\Sigma$ te vervangen door een diagonaalmatrix met de $k$ grootste singuliere waarden op de diagonaal.
	\end{mydef}

	Hierdoor geldt de eigenschap
	$$
		\norm{A-A_k}_2 = min_{B \in \mathbb{R}^{m \times m} \text{rang}(B) \leq k} \norm{A-B}_2 = \sigma_k+1
	$$
	
	\todo{Lagerangbenadering met QR}
	
	
	\subsection{Kleinste-Kwadratenbenadering}
	Om de coëfficiënten te bepalen wordt een Vandermondematrix $A$ opgesteld. 
	De te minimaliseren fout bij KK-benadering wordt gegeven door
	$$
	\min_{x \in \mathbb{R}^n} \norm{b-Ax}_2 
	= \min_{x \in \mathbb{R}^n} \sqrt{\sum_{i=1}^{m}(b_i - \sum_{j=1}^{n}a_{i,j}x_j)^2}
	$$
	met $r=b-Ax$ de \textit{residuvector}.
	
	Dit probleem kan opgelost worden door $x$ te bepalen in 
	$$
	A^TAx = A^Tb
	$$
	De Vandermondematrix $A$ is slecht geconditioneerd. We zoeken dus andere manieren om het KK-probleem op te lossen.\\
	
	\subsubsection{Oplossing met QR-ontbinding}
	
	Indien de QR-factorisatie van $A$ bekend is, kan deze gebruikt worden om een oplossing voor het KK-probleem te vinden:
	$$
	\min_{x \in \mathbb{R}^n} \norm{b-Ax}_2  
	= \min_{x \in \mathbb{R}^n} \norm{b-QRx}_2
	= \min_{x \in \mathbb{R}^n} \norm{Q^Tb-RAx}_2 
	$$
	Aangezien vermenigvuldiging vooraan met een orthogonale matrix de norm behoudt. \\	
	De  vector $Q^Tb=c$ kan opgesplitst worden in  de volgende componenten:
	$
	\begin{bmatrix}
		c_1\\
		c_2
	\end{bmatrix}
	$
	met $c_1 \in \mathbb{R}^n$ en $c_2 \in \mathbb{R}^{m-n}$\\
	Hieruit volgt:
	$$
	\min_{x \in \mathbb{R}^n} \norm{b-Ax}_2 
	= 	\min_{x \in \mathbb{R}^n} \norm{
		\begin{bmatrix}
		c_1\\
		c_2
		\end{bmatrix}
		-
		\begin{bmatrix}
			\hat{R}\\
			0
		\end{bmatrix}
		x}_2 
	$$
	Volgens de stelling van Pythagoras geldt:
	$$
	\min_{x \in \mathbb{R}^n} \norm{b-Ax}_2^2
	= \min_{x \in \mathbb{R}^n} (\norm{c_1-\hat{R}x}_2^2 + \norm{c_2}_2^2)
	$$
	De vector $x$ met coëfficiënten met minimale fout kan dus ook bekomen worden als $x$ de oplossing van $\hat{R}x = c_1$\\
	
	\textbf{Complexiteit:} $\mathcal{O}(mn) + \mathcal{O}n^2$ indien QR-factorisatie bekend.\\
	\textbf{Stabiliteit:} stabiel indien $A$ van volle rang.
	

	\subsection{Eigenwaardenproblemen}
	
	\subsubsection{Methode van de machten}
	Deze methode vindt de eigenvector bij de grootste eigenwaarde en is geschikt voor ijle matrices.
	
	\begin{algorithm}[!ht]
		\caption{Methode der machten}
		\begin{algorithmic}[1]
			\Procedure{EigenPowermethod}{}
				\State $q_1$ random
				\For{$k=0,1,2,...$}
					\State take $\gamma_k$ such that $\norm{q_{k+1}}_2 = 1$
					\State $q_{k+1} = \frac{Aq_k}{\gamma_k} $
				\EndFor
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}

	$q_k$ zal convergeren naar $\gamma_1 x_1$
	
	\textbf{Voordelen:}
	\begin{itemize}
		\item Eenvoudige berekeningen
		\item zeer efficiënt voor ijle matrices
	\end{itemize}
	\textbf{Nadelen:}
	\begin{itemize}
		\item Zeer trage convergentie als $\lambda_1$ niet sterk dominant is.
	\end{itemize}

	\textbf{Convergentie:} lineair, afhankelijk van afstand tussen grootste eigenwaarden.
		
	\subsubsection{Deelruimte-iteratie}
	
	We itereren nu niet meer op één vector (methode der machten) maar op de volledige ruimte opgespannen door een orthonormaal stel vectoren.\\
	
	Voor $n$ eigenwaarden:
	
	\begin{algorithm}[!ht]
		\caption{Deelruimte-iteratie}
		\begin{algorithmic}[1]
			\Procedure{EigenPartialSpace}{}
				\State $\hat{Q}_0 = 
				\begin{bmatrix}
					q_1^0 & q_2^0 & ... & q_n^0
				\end{bmatrix}
				$ random orthonormaal
				\For{$k=0,1,2,...$}
					\State $\hat{P}_k = A\hat{Q}_{k-1}$
					\State $\hat{Q}_k \hat{R}_k = \hat{P}_k$ door QR-factorisatie
				\EndFor
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}

	\textbf{Convergentie:} lineair, afhankelijk van afstand tussen eigenwaarden.
	
	\subsubsection{QR-algoritme zonder shift}
	
	\begin{algorithm}[!ht]
		\caption{QR-algoritme zonder shift}
		\begin{algorithmic}[1]
			\Procedure{EigenQR}{}
			\For{$k=1,2,3...$}
				\State $A_k = Q_k R_k$ door QR-factorisatie
				\State $A_{k+1} = R_k Q_k$
			\EndFor
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}

	$\tilde{Q}_k = 
	\begin{bmatrix}
		\tilde{q}_1^{(k)} & \tilde{q}_2^{(k)} & ... & \tilde{q}_i^{(k)}
	\end{bmatrix}$ convergeert naar de eigenvctoren van $A$.\\
	
	
	\textbf{Complexiteit:} $\mathcal{O}(km^3)$
	
	\subsubsection{Omvorming tot Hessenbergmatrix}
	
	Het aantal stappen in het QR-algoritme kan teruggebracht worden door eerst de matrix om te vormen naar een \textit{Hessenbergvorm} m.b.v. Givens-rotaties.\\
		
	\textbf{Complexiteit van omvorming:} $\mathcal{O}(m^3)$
	
	\subsubsection{QR-algoritme met shift}
	
	De convergentie van het QR-algoritme kan versneld worden door een \textit{shift} toe te passen.
	

	
	\begin{algorithm}[!ht]
		\caption{QR-algoritme met shift}
		\begin{algorithmic}[1]
			\Procedure{EigenQRShift}{}
				\State $A=A_0$ Hessenberg
				\For{$k=1,2,3...$}
					\State $\kappa = a_{m,m}^{(k)}$
					\State $A_k - \kappa \mathbb{1} = Q_k R_k$ door QR-factorisatie
					\State $A_{k+1} = R_k Q_k + \kappa \mathbb{1}$
				\EndFor
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}	
	$\tilde{Q}_k = 
	\begin{bmatrix}
	\tilde{q}_1^{(k)} & \tilde{q}_2^{(k)} & ... & \tilde{q}_i^{(k)}
	\end{bmatrix}$ convergeert naar de eigenvectoren van $A$.\\
	
	
	\textbf{Complexiteit:} $\mathcal{O}(km^3)$ \\
	\textbf{Convergentie:} kubisch indien symmetrisch, anders lineair, afhankelijk van afstand tussen eigenwaarden.
	
	\subsection{Toepassingen in de grafentheorie}
	
	\subsubsection{PageRank}
	
	Stel een grafe op van alle links op webpagina's naar andere webpagina's. Het gewicht van de edges wordt genormaliseerd met het aantal links op de pagina die verwijst. Stel deze grafe voor als matrix $A$\\
	
	$A$ geeft ook een Markov-model voor het web.\\
	
	Gebaseerd op de matrix $A$ wordt aan elke pagina $P_i$ een score $r(P_i) \geq 0$ toegekend via de volgende principes:
	\begin{enumerate}
		\item als veel andere pagina's naar $P_i$ verwijzen, begunstigd dit $r(P_i)$
		\item als $r(P_i)$ hoog is, begunstigd dit de score van pagina's waarnaar $P_i$ verwijst.
		\item als $P_i$ weinig links heeft is dit begunstigend voor de pagina's waarnaar $P_i$ verwijst.
	\end{enumerate}

	Vervolgens wordt $A$ omgevormd tot een \textit{irreduceerbare} en \textit{rij-stochastische} matrix $\hat{A}$. Volgens deze eigenschappen heeft $\hat{A}$ $1$ als grootste eigenwaarde en kan de \textit{PageRank}-vector met scores dus gevonden worden door het volgende stelsel op te lossen:
	$$ \hat{A}^T \Pi = 1 \Pi $$
	wat neer komt op het bepalen van de eigenvector van $\hat{A}$ horende bij de dominante eigenwaarde 1.
	
	\subsubsection{Meest centrale knoop}
	
	Centraliteit van een knoop kan gemeten worden door het aantal verbindingen of lussen. Het aantal lussen van lengte $n$ vertrekkende uit knoop $i$ is $(A^n)_{i,i}$. Voor de definitie van de meest centrale knoop moeten lussen van elke lengte worden meegeteld, maar hoe groter de lengte, hoe minder gewicht er gegeven moet worden aan die lus.\\
	
	\begin{mydef}
		
		De centraliteit van een knoop $i$ in matrix $A$ wordt gegeven door $(e^A)_{i,i}$ met $e^A$ de matrix-exponentiële van matrix $A$, die berekend wordt als
		$$
		\mathbb{1} + \frac{A}{1!} + \frac{A^2}{2!} + ... + \frac{A^n}{n!} + ...
		$$
	\end{mydef}
	
	Indien de eigenwaardenontbinding van $A$ bekend is als
	$$
	 A = X diag(\lambda_1, ... , \lambda_N) X^{-1}
	$$
	kan de matrix-exponentiële berekend worden als
	$$
		e^A = X diag(e^{\lambda_1}, ... , e^{\lambda_N}) X^{-1}
	$$
	
	\section{Optimalisatie}
	
	\begin{mydef}
		De gradiënt van een functie $f: \mathbb{R}^n \to \mathbb{R}$ wordt gedefinieerd als
		$$
		\mathcal{r} f(x) :=
		\begin{bmatrix}
		\frac{\partial f(x)}{\partial x_1} & ... & \frac{\partial f(x)}{\partial x_n}
		\end{bmatrix}^T
		$$
	\end{mydef}
	
	\begin{mydef}
		De Hessiaan van een functie $f: \mathbb{R}^n \to \mathbb{R}$ wordt gedefinieerd als
		$$
		\mathcal{r}^2 f(x) :=
		\begin{bmatrix}
		\frac{\partial^2 f(x)}{\partial x_i \partial x_j}
		\end{bmatrix}_{i,j=1}^n
		\in \mathbb{R}^{n\times n}
		$$
	\end{mydef}
	
	\begin{mydef}
		De Jacobiaan van een functie $K: \mathbb{R}^n \to \mathbb{R}^m$ wordt gedefinieerd als
		$$
		J_Kf(x) :=
		\begin{bmatrix}
		\frac{\partial k_i (x_1 ..., x_n)}{\partial x_j}
		\end{bmatrix}_{i,j=1}^n
		\in \mathbb{R}^{n\times n}
		$$
	\end{mydef}
	
	De Hessiaan van $f(x)$ is de Jacobiaan van haar gradiënt $\mathcal(r) f(x)$
	
	\subsection{Optimalisatieproblemen zonder beperkingen}
	
	De helling in de richting van de gradiënt is het grootst.
	
	\subsubsection{Algemene afdalingsmethode}
	
	Een iteratie van afdalingsmethode om een minimum van een functie $f$ te vinden begint met het vinden van een volgend iteratiepunt $x^(k)$. Dit gebeurt in twee stappen:
	\begin{enumerate}
		\item Bereken een \textit{trial}-stap $h^{(k)}$ waarvoor $[h^{(k)}]^T f(x^{(k)}) < 0$
		\item Zoek de stapgrootte $\alpha^{(k)} > 0$ zodat $x^{(k+1)} = x^{(k)} + \alpha^{(k)} h^{(k)}$ een lagere functiewaarde geeft dan $f(x^{(k)})$
	\end{enumerate}

	\todo{algoritme}

	In veel methodes neemt $\alpha$ af naarmate het minimum nadert.	
	
	\subsubsection{Methode van de steilste afdaling}
	
	De richting waarin $f$ het snelst daalt wordt bepaald door 
	$$
		h^{(k)} = -\nabla f(x^{(k)})
	$$
	
	Dit zorgt voor inefficiëntie door een zig-zagverloop omdat $\alpha^{(k)}$ vaak te groot is.	
	
	\subsubsection{Methode van Newton}
	
	De afdaalrichting $h^{(k)}$ wordt bepaald door $f(x)$ in de omgeving van $x^{(k)}$ door een \textit{kwadriek}:
	$$
		f(x^{(k)} + h) \approx q(h) := f(x^{(k)}) + h^T \nabla f(x^{(k)}) + \frac{1}{2} h^T \nabla^2 f(x^{(k)})h
	$$
	Deze benaderende functie heeft in punt $x^{(k)}$ dezelfde gradiënt (raakvlak) en dezelfde Hessiaan (kromming) als $f(x)$.
	
	De richting naar het nieuwe iteratiepunt is het minimum van deze kwadriek, berekend door $ \nabla q(h) = 0 $:
	$$
		h^{(k)} = -[\nabla^2f(x^{(k)})]^{-1} \nabla f(x^{(k)})
	$$
	
	\textbf{Convergentie:} Kwadratisch indien Hessiaan niet-singulier in het attractiepunt en startwaarde in attractiegebied van minimum.
	
	\subsection{Optimalisatieproblemen met beperkingen}
	
	\subsubsection{Gelijkheidsbeperkingen}	
	Voor \textbf{één gelijkheidsbeperking} geldt de eigenschap dat als $x^*$ een lokale minimizer is en $\nabla g(x^*) \neq 0$ er een $\lambda \in \mathbb{R}$ bestaat zo dat $-\nabla f(x^*) = \lambda \nabla g(x^*)$\\
	
	Hiermee kunnen kandidaat minima gevonden worden door het volgende stelsel op te lossen met de methode van Newton-Raphson:
	\begin{equation*}
		\left\{
			\begin{array}{rr}
				\nabla f(x) + \lambda \nabla g() = 0\\
				g(x) = 0
			\end{array}
		\right.
	\end{equation*}
		
	Voor \textbf{meerdere gelijkheidsbeperkingen} geldt de eigenschap dat als $x^*$ een lokale minimizer is en de vectoren
	$$
		{\nabla g_1(x^*), ... \nabla g_p(x^*)}
	$$
	zijn lineiair onafhankelijk, dan bestaan er $\lambda_1, ... , \lambda_p \in \mathbb{R}$ zo dat
	$$
		-\nabla f(x^*) = \sum_{i=1}^{p} \lambda_i \nabla g_i(x^*)
	$$
	
	Hiermee kunnen kandidaat minima gevonden worden door het volgende stelsel op te lossen met de methode van Newton-Raphson:
	$$	
		\left\{
			\begin{array}{rr}
				\nabla f(x) + \sum_{i=1}^{p} \lambda_i \nabla g_i(x) = 0\\
				g_1(x) = 0\\
				...\\
				g_p(x) = 0
			\end{array}
		\right.
	$$

	
	\subsubsection{Ongelijkheidsbeperkingen}
	
	\todo{TODO}
	
	\section{Trigoniometrische benadering}
	
	\subsection{Fourier-analyse}
	Een Fourier-transformatie stelt een functie, die origineel in het tijdsdomein werd voorgesteld, voor in het frequentiedomein. Afhankelijk van de situatie onderscheiden we de volgende Fourier-transformaties:
		\begin{enumerate}
			\item \textbf{Continue Fourier-transformatie} wanneer $x(t)$ gedefinieerd voor $t \in (-\infty, \infty)$.
			\item \textbf{Fourier-reeksontwikkeling} wanneer $x(t)$ gedefinieerd is op een compact interval $[a, b]$.
			\item \textbf{Discrete Fourier-transformatie} wanneer $x(t)$ bemonsterd op een eindig aantal equidistante tijdstippen.
			\item \textbf{Z-transformatie} wanneer $x(t)$ bemonsterd op een oneindig aantal equidistante tijdstippen.
		\end{enumerate}	
	
	\subsection{Discrete Fourier-transformatie}
	
	\subsubsection{DFT en IDFT}
	
	\begin{mydef}
		Voor een eindige rij $\{x_n\}_{n=0}^{N-1}$ met $N$ willekeurige getallen wordt de discrete Fourier-transformatie (DFT) gegeven door
		$$
			X_k = \sum_{n=0}^{N-1} x_n W_N^{kn}  
		$$
		voor $k=0, ... , N-1$ met
		$$
			W_N = e^{2\pi i/N}
		$$
	\end{mydef}

	\begin{mydef}
		Voor een eindige rij $\{X_k\}_{k=0}^{N-1}$ met $N$ willekeurige getallen wordt de inverse discrete Fourier-transformatie (IDFT) gegeven door
		$$
		x_n = \sum_{k=0}^{N-1} X_k W_N^{-kn}  
		$$
		voor $n=0, ... , N-1$ met
		$$
		W_N = e^{2\pi i/N}
		$$
	\end{mydef}

	Uit de eigenschap dat $W_N^{k+N} = W_N^k$ volgt dat er slechts $N$ verschillende $W_N^{kn}$ en $W_N^{-kn}$ zijn. 
	
	\textbf{Complexiteit van directe berekening:} $\mathcal{O}(N^2)$

	\subsubsection{Daniel-Lanczos splitsingsalgoritme}
	
	Vanwege de eigenschappen $W_N^{N/2}+k = -W_N^k$, $X_{N/2+k}^{even} = X_k^{even}$ en $X_{N/2+k}^{odd} = X_k^{odd}$ geldt dat
	$$
		X_k = X_k^{even} + W_N^k X_k^{odd}
	$$
	
	\begin{algorithm}[!ht]
		\caption{Daniel-Lanczos Splitsingsalgoritme}
		\begin{algorithmic}[1]
			\Procedure{DFTSplit}{}
				\State $\{X_k^{even}\}_{k=0}^{N/2-1} = \{\sum_{n=0}^{N/2-1} x_{2n}W_{N/2}^k\}_{k=0}^{N/2-1}$
				\State $\{X_k^{even}\}_{k=0}^{N/2-1} = \{\sum_{n=0}^{N/2-1} x_{2n}W_{N/2}^k\}_{k=0}^{N/2-1}$
				\State $\{X_k\}_{k=0}^N = \{X_{k/2}^{even} + W_N^k + X_{k/2}^{odd}\}_{k=0}^N$
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}

	\textbf{Complexiteit:} $\mathcal{O}(N^2/2)$

	\subsubsection{Snelle Fourier-transformatie}
	
	Met de combinatiestap van het Daniel-Lanczos-splitsingsalgoritme kunnen we een recursief algoritme opstellen
	
	\begin{algorithm}[!ht]
		\caption{Snelle Fourier-transformatie}
		\begin{algorithmic}[1]
			\Procedure{FFT}{}
			\If{$N=1$}
				\State $X_k=x_k$ 
			\Else
				\State reorder $\{x_k\}$
				\State $\{X_k\} = \{FFT(x_{k/2}^{even}) + W_N^k + FFT(x_{k/2}^{odd})\}$
			\EndIf
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}

	\textbf{Complexiteit:} $\mathcal{O}(Nlog_2(N))$
	
	\subsection{Symmetrische discrete Fourier-transformaties}
	
	\subsubsection{Discrete cosinustransformatie}
	
	\todo{wat is een oneven uitbreiding}
	
	De DFT van een rij met even symmetrie wordt gegeven door
	$$
		X_k = 2\sum_{n=0}^{N}{''} x_n cos(\pi kn/N)
	$$
	Dit is een transformatie van de symmetrische rij en is verwant aan de discrete cosinustransformatie.
	
	\begin{mydef}
		De discrete cosinustransformatie (DCT) wordt gedefinieerd als
		$$
			X_k = \sum_{n=0}^{N}{''} x_n cos(\pi kn/N)
		$$
		voor $k=0,...,N$
	\end{mydef}

	\begin{mydef}
		De inverse discrete cosinustransformatie (IDCT) wordt gedefinieerd als
		$$
		x_n = \frac{2}{N}\sum_{k=0}^{N}{''} X_k cos(\pi kn/N)
		$$
		voor $n=0,...,N$
	\end{mydef}

	\subsubsection{Snelle cosinustransformatie}
	
	Om de cosinustransformatie efficiënt te berkenen, kan een algoritme gelijkaardig aan FFT worden.
	
	\todo{FCT}

	\begin{algorithm}[!ht]
		\caption{Snelle cosinustransformatie}
		\begin{algorithmic}[1]
			\Procedure{FCT}{}
			\State 
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	\subsubsection{Discrete sinustransformatie}
	
	De DFT van een rij met oneven symmetrie wordt gegeven door
	$$
		X_k = 2i\sum_{n=1}^{N-1} x_n sin(\pi kn/N)
	$$
	Dit is een transformatie van de symmetrische rij en is verwant aan de discrete sinustransformatie.	
	\begin{mydef}
		De discrete sinustransformatie (DST) wordt gedefinieerd als
		$$
		X_k = \sum_{n=1}^{N-1} x_n sin(\pi kn/N)
		$$
		voor $k=1,...,N-1$
	\end{mydef}
	
	\begin{mydef}
		De inverse discrete sinustransformatie (IDST) wordt gedefinieerd als
		$$
		x_n = \frac{2}{N}\sum_{k=1}^{N-1} X_k sin(\pi kn/N)
		$$
		voor $n=1,...,N-1$
	\end{mydef}
	
	\subsection{Meerdimensionele Fourier-transformatie}
	\todo{Deze sectie als er tijd over is}
	
	\section{Toevalsgeneratoren}

	
	\subsection{Genereren van willekeurige getallen}
	
	Een software-generator moet voldoen aan de volgende eigenschappen:
	
	\begin{itemize}
		\item snel en weinig geheugengebruik
		\item draagbaar over verschillende platformen
		\item voldoende lange periode
		\item reproduceerbare gegenereerde rij (bv. via seed)
		\item gegenereerde getallen voldoen aan eigenschappen van willekeurige getallen:
	\end{itemize}

	\subsubsection{Lineaire congruentiële generator}

	\begin{mydef}
		Een lineaire congruentiële generator (LCG) met parameters (a, c, m) genereert getallen volgens de recursiebetrekking
		$$
			X_i+1 = (aX_i + c)\text{ mod }m
		$$
		waarin $a$ de \textit{multiplier}, $c$ het \textit{increment} en $m$ de \textit{modulus}.
	\end{mydef}

	Enkele keuzes voor $(a,c,m)$ die een grote periode opleveren zijn de volgende (met $b$ het aantal bits in een geheugenplaats en $k \in \mathbb{Z}$):
	\begin{itemize}
		\item Voor $m=2^b$, $c \neq 0$ is de maximale periode $P=m=2^b$, die kan bereikt worden wanneer $c$ relatief priem met $m$ en $a=1+4k$.
		\item Voor $m=2^b$, $c=0$ is de maximale periode $P=m/4=2^b-2$, die kan bereikt worden wanneer $X_0$ oneven is en als $a=3+8k$ of $a=5+8k$.
		\item Als $m$ een priemgetal en $c=0$ is de maximale periode $P=m-1$, die kan bereikt worden als $a$ de eigenschap heeft dat de kleinste $k$ waarvoor geldt dat $a^k-1$ deelbaar is door $m$ gelijk is aan $m-1$
	\end{itemize}
	
	\subsection{Testen voor toevalsgeneratoren}
	
	\subsubsection{Chi-kwadraattest}
	
	De chi-kwadraattest is een frequentietest om na te gaan of de gegenereerde getallen voldoen aan de uniforme verdeling.\\
	
	De chi-kwadraattest maakt gebruik van de toetsingsgrootheid
	$$
		\chi_{n-1}^2 = \sum_{i=1}^{n} \frac{(O_i - E_i)^2}{E_i}
	$$
	met $O_i$ het aantal observaties in klasse $i$, $E_i$ het verwachte aantal punten in klasse $i$ en $n$ het aantal klassen.
	
	
	\subsubsection{Kolmogorov-Smirnov-test}
	
	De Kolmogorov-Smirnov-test is een frequentietest om na te gaan of de gegenereerde getallen voldoen aan de uniforme verdeling.\\
	
	\begin{algorithm}[!ht]
		\caption{Kolmogorov-Smirnovtest}
		\begin{algorithmic}[1]
			\Procedure{DFTSplit}{KSTest}
				\State $R_{(1)} \leq ... \leq R_{(N)} = sort(R_1, ..., R_N)$
				\State $D^+ = \max_{1 \leq i \leq N}\{\frac{i}{N} - R_{(i)}\}$
				\State $D^- = \max_{1 \leq i \leq N}\{R_{(i)} - \frac{i-1}{N}\}$
				\State $D = max(D^+, D^-)$
				\If{$D > D_{\alpha}$}
					\State reject $H_0$
				\Else
					\State accept $H_0$
				\EndIf				
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	
	\subsubsection{Autocorrelatietest}
	
	Een autocorrelatietest vindt het onderling verband in een rij getallen.
	
	\todo{Gekke wiskunde}
	
	\subsection{Toevalsgeneratoren voor discrete verdelingen}
	
	\begin{mydef}
		Stel dat $X$ een discrete willekeurige variabele is met cdf $F$. De inverse distributiefunctie (idf) van $X$ is dan
		$$
			F^*:[0,1] \rightarrow \chi : u \mapsto F^*(u) = \min_x\{x:u<F(x)\}
		$$
	\end{mydef}

	Als $U$ een uniform verdeelde willekeurige variabele is en $F^*(x)$ de idf van $F(x)$, dan is een willekeurige variabele $Z=F^*(U)$ verdeeld volgens $F$
	
	\subsection{Toevalsgeneratoren voor continue verdelingen}
	
	\begin{mydef}
		Stel dat $X$ een continue willekeurige variabele is met cdf $F$. De inverse distributiefunctie (idf) van $X$ is dan
		$$
		F^{-1}:[0,1] \rightarrow \chi : u \mapsto F^{-1}(u) = \min_x\{x:u<F(x)\}
		$$
	\end{mydef}

	Het is niet altijd eenvoudig om een uitdrukking voor $F^{-1}$ op te stellen. Daarom zijn er enkele methodes.
	
	\subsubsection{Transformatiemethode}
	
	Als $U$ een uniform verdeelde willekeurige variabele is en $F^{-1}(x)$ de idf van $F(x)$, dan is een willekeurige variabele $Z=F^{-1}(U)$ verdeeld volgens $F$
	
	\subsubsection{Box-Muller-algoritme}
	
	Het Box-Muller-algoritme wordt gebruikt om getallen volgens $N(0,1)$ te genereren.
	
	\begin{algorithm}[!ht]
		\caption{Box-Muller-algoritme}
		\begin{algorithmic}[1]
			\Procedure{BoxMullerNormal}{}
				\State $U_ 1, U_2 \sim U(0,1)$ random
				\State $Z_1 = \sqrt{-2 \log(U_1)} \cos(2 \pi U_2)$
				\State $Z_2 = \sqrt{-2 \log(U_1)} \sin(2 \pi U_2)$
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	$Z_1$ en $Z_2$ zijn onafhankelijke willekeurige variabelen verdeeld volgens $N(0,1)$
	
	
	\subsubsection{Som van Twaalf}
	
	Het Box-Muller-algoritme wordt gebruikt om getallen volgens $N(0,1)$ te genereren.
	
	\begin{algorithm}[!ht]
		\caption{Som van twaalf}
		\begin{algorithmic}[1]
			\Procedure{SumOf12Normal}{}
				\State $U_i \sim U(0,1)$ for $i=1,2,...,12$
				\State $Z = \sum_{12}^{i=1}U_i - 6$
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}

	$Z$ is bij benadering verdeeld volgens $N(0,1)$
	
	\subsubsection{Acceptance-rejection methode}
	
	De accpetance-rejection methode kan gebruikt worden om getallen volgens een willekeurige verdelingsfunctie $p(x)$ te genereren, gegeven een andere verdelingsfunctie $q(x)$ waar een generator voor bestaat.\\
	
	In de praktijk wordt voor $q(x)$ vaak $U(0,1)$ genomen.
	
	\begin{algorithm}[!ht]
		\caption{Acceptance-rejection methode}
		\begin{algorithmic}[1]
			\Procedure{AcceptRejectRandom}{}
				\State $Y \sim q(x)$ random
				\State $\hat{x} \in \text{dom}(p(x))$
				\If{$ 0< Y  < p(\hat{x})/q(\hat{x}) $}
					\State \textbf{accept}
				\ElsIf{$ p(\hat{x})/q(\hat{x}) < Y < 1$}
					\State \textbf{reject}
				\EndIf
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	
	\section{Discrete eventsimulaties}
	
	\subsection{Discrete eventsystemen}
	
	Een \textit{lijst} is een verzameling entiteiten met een ordening. Een \textit{event notice} is een aankondiging dat een \textit{event} op een bepaald moment zal plaastvinden of plaats heeft gevonden. Een \textit{event list} is een lijst van \textit{event notices}.\\

	Vertragingen komen overeen met \textit{conditional wait}.\\
	Activiteiten komen overeen met \textit{unconditional wait}.
	
	\begin{mydef}
		Een discrete eventsimulatie is een modellering over een bepaalde tijdspanne van een systeem waarvan de status wijzigt op discrete ogenblikken in de tijdn namelijk op die ogenblikken waarop gebeurtenissen plaatsvinden.
	\end{mydef}
	
	\subsection{Wachtrijen}
	
	\subsubsection{Algemene wachtrijsimulatie}
	
	De simulatie van een wachtrij verloopt volgens de volgende stappen:
	
	\begin{enumerate}
		\item Bepaal de karakteristieken van de invoer (bv. waarschijnlijkheidsverdeling).
		\item Stel een simulatietabel op en initializeer de eerste rij.
		\item Genereer de invoer voor elke iteratie en evalueer de uitvoerfunctie voor elke iteratie
	\end{enumerate}

	De \textit{systeemstatus} is gelijk aan het aantal klanten in de wachtrij. Een \textit{gebeurtenis} is een plotse wijziging in de systeemstatus. \\
	
	Voor wachtrijsystemen wordt het algemene notatiesysteem $A/B/c/N/K$ gebruikt, met
	\begin{itemize}
		\item $A$ de verdeling van de aankomsten
		\item $B$ de verdeling van de bedieningstijd
		\item $c$ het aantal servers/kanalen
		\item $N$ de capaciteit van de wachtrij
		\item $K$ de grootte van de klantenpopulatie
	\end{itemize}

	Volgens de bovenstaande verdelingen kan er een groot aantal aankomsten van klanten en bedieningstijden gegenereerd worden. Hiermee kan dan een bedieningstabel opgesteld worden die volgens de wet van de grote getallen representatief zal zijn voor het wachtrijsysteem.

	\subsubsection{Single-server-wachtrijen}
	\begin{table}[!ht]
	\makebox[\linewidth]{


		\begin{tabular}{|p{.1\textwidth}|p{.125\textwidth}p{.125\textwidth}p{.125\textwidth}p{.125\textwidth}p{.125\textwidth}p{.125\textwidth}p{.125\textwidth}p{.125\textwidth}|}
			\hline
			Klant & Tijd tussen aankomsten & Aankomst- tijd & Dienstduur & Begintijd dienst & Wachtduur in rij & Eindtijd- stip dienst & Duur klant in systeem & Inactieve tijd van server \\ \hline
			1     &                        &                &            &                  &                  &                       &                       &                           \\
			2     &                        &                &            &                  &                  &                       &                       &                           \\
			...   &                        &                &            &                  &                  &                       &                       &                           \\
			n     &                        &                &            &                  &                  &                       &                       &                           \\ \hline
		\end{tabular}

	}
	
		\end{table}
	
	De bovenstaande tabel geeft een voorbeeld van een simulatietabel voor een single-channel wachtrij.
	
	\subsubsection{Multi-server-wachtrijen}
	
	Dit werkt gelijkaardig aan het bovenstaande principe. Als een server vrij is, wordt de volgende klant onmiddelijk geholpen door de vrije server.\\
	
	Indien alle servers bezet zijn, wordt de tijd waarop de eerste server vrij komt berekend door het minimum van de huidige eindtijden van de services te nemen.
	

	
	\subsection{Inventarissystemen}
	
	De inventaris wordt opgemaakt in periodes van lengte $N$. De maximale voorraad wordt gegeven door $M$. Een te grote voorraad brengt kosten met zich mee. Een negatieve voorraad komt overeen met bestellingen van klanten en is ook te vermijden.\\
	
	Mogelijke gebeurtenissen zijn
	\begin{itemize}
		\item een vraag naar een item in voorraad.
		\item het opstellen van een inventaris.
		\item het ontvangen van een levering.
	\end{itemize}

	Het is mogelijk dat er een stochastische wachttijd is voor een levering.

\end{document}